// Code generated by protoc-gen-go.
// source: addressbook.proto
// DO NOT EDIT!

package OAR1

import proto "3rdparty/src/proto"
import json "encoding/json"
import math "math"

import "io"
import "log"
import "net"
import "net/rpc"
import "time"
import protorpc "3rdparty/src/protorpc"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

type Person_PhoneType int32

const (
	Person_MOBILE Person_PhoneType = 0
	Person_HOME   Person_PhoneType = 1
	Person_WORK   Person_PhoneType = 2
)

var Person_PhoneType_name = map[int32]string{
	0: "MOBILE",
	1: "HOME",
	2: "WORK",
}
var Person_PhoneType_value = map[string]int32{
	"MOBILE": 0,
	"HOME":   1,
	"WORK":   2,
}

func (x Person_PhoneType) Enum() *Person_PhoneType {
	p := new(Person_PhoneType)
	*p = x
	return p
}
func (x Person_PhoneType) String() string {
	return proto.EnumName(Person_PhoneType_name, int32(x))
}
func (x Person_PhoneType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Person_PhoneType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Person_PhoneType_value, data, "Person_PhoneType")
	if err != nil {
		return err
	}
	*x = Person_PhoneType(value)
	return nil
}

type Person struct {
	Name             []byte                `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Id               *int32                `protobuf:"varint,2,req,name=id" json:"id,omitempty"`
	Email            *string               `protobuf:"bytes,3,opt,name=email,def=default@" json:"email,omitempty"`
	Phone            []*Person_PhoneNumber `protobuf:"bytes,4,rep,name=phone" json:"phone,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}

const Default_Person_Email string = "default@"

func (m *Person) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *Person) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Person) GetEmail() string {
	if m != nil && m.Email != nil {
		return *m.Email
	}
	return Default_Person_Email
}

func (m *Person) GetPhone() []*Person_PhoneNumber {
	if m != nil {
		return m.Phone
	}
	return nil
}

type Person_PhoneNumber struct {
	Number           *string           `protobuf:"bytes,1,req,name=number" json:"number,omitempty"`
	Type             *Person_PhoneType `protobuf:"varint,2,opt,name=type,enum=OAR1.Person_PhoneType,def=1" json:"type,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Person_PhoneNumber) Reset()         { *m = Person_PhoneNumber{} }
func (m *Person_PhoneNumber) String() string { return proto.CompactTextString(m) }
func (*Person_PhoneNumber) ProtoMessage()    {}

const Default_Person_PhoneNumber_Type Person_PhoneType = Person_HOME

func (m *Person_PhoneNumber) GetNumber() string {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return ""
}

func (m *Person_PhoneNumber) GetType() Person_PhoneType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_Person_PhoneNumber_Type
}

type AddressBook struct {
	Person           []*Person `protobuf:"bytes,1,rep,name=person" json:"person,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *AddressBook) Reset()         { *m = AddressBook{} }
func (m *AddressBook) String() string { return proto.CompactTextString(m) }
func (*AddressBook) ProtoMessage()    {}

func (m *AddressBook) GetPerson() []*Person {
	if m != nil {
		return m.Person
	}
	return nil
}

type CheckResponse struct {
	Msg              *string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CheckResponse) Reset()         { *m = CheckResponse{} }
func (m *CheckResponse) String() string { return proto.CompactTextString(m) }
func (*CheckResponse) ProtoMessage()    {}

func (m *CheckResponse) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("OAR1.Person_PhoneType", Person_PhoneType_name, Person_PhoneType_value)
}

type CheckService interface {
	Check(in *AddressBook, out *CheckResponse) error
}

// AcceptCheckServiceClient accepts connections on the listener and serves requests
// for each incoming connection.  Accept blocks; the caller typically
// invokes it in a go statement.
func AcceptCheckServiceClient(lis net.Listener, x CheckService) {
	srv := rpc.NewServer()
	if err := srv.RegisterName("CheckService", x); err != nil {
		log.Fatal(err)
	}

	for {
		conn, err := lis.Accept()
		if err != nil {
			log.Fatalf("lis.Accept(): %v\n", err)
		}
		go srv.ServeCodec(protorpc.NewServerCodec(conn))
	}
}

// RegisterCheckService publish the given CheckService implementation on the server.
func RegisterCheckService(srv *rpc.Server, x CheckService) error {
	if err := srv.RegisterName("CheckService", x); err != nil {
		return err
	}
	return nil
}

// NewCheckServiceServer returns a new CheckService Server.
func NewCheckServiceServer(x CheckService) *rpc.Server {
	srv := rpc.NewServer()
	if err := srv.RegisterName("CheckService", x); err != nil {
		log.Fatal(err)
	}
	return srv
}

// ListenAndServeCheckService listen announces on the local network address laddr
// and serves the given CheckService implementation.
func ListenAndServeCheckService(network, addr string, x CheckService) error {
	lis, err := net.Listen(network, addr)
	if err != nil {
		return err
	}
	defer lis.Close()

	srv := rpc.NewServer()
	if err := srv.RegisterName("CheckService", x); err != nil {
		return err
	}

	for {
		conn, err := lis.Accept()
		if err != nil {
			log.Fatalf("lis.Accept(): %v\n", err)
		}
		go srv.ServeCodec(protorpc.NewServerCodec(conn))
	}
}

type CheckServiceClient struct {
	*rpc.Client
}

// NewCheckServiceClient returns a CheckService rpc.Client and stub to handle
// requests to the set of CheckService at the other end of the connection.
func NewCheckServiceClient(conn io.ReadWriteCloser) (*CheckServiceClient, *rpc.Client) {
	c := rpc.NewClientWithCodec(protorpc.NewClientCodec(conn))
	return &CheckServiceClient{c}, c
}

func (c *CheckServiceClient) Check(in *AddressBook, out *CheckResponse) error {
	return c.Call("CheckService.Check", in, out)
}

// DialCheckService connects to an CheckService at the specified network address.
func DialCheckService(network, addr string) (*CheckServiceClient, *rpc.Client, error) {
	c, err := protorpc.Dial(network, addr)
	if err != nil {
		return nil, nil, err
	}
	return &CheckServiceClient{c}, c, nil
}

// DialCheckServiceTimeout connects to an CheckService at the specified network address.
func DialCheckServiceTimeout(network, addr string,
	timeout time.Duration) (*CheckServiceClient, *rpc.Client, error) {
	c, err := protorpc.DialTimeout(network, addr, timeout)
	if err != nil {
		return nil, nil, err
	}
	return &CheckServiceClient{c}, c, nil
}
